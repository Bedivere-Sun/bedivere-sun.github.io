<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"koorimeo.gitee.io","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="一个属于克里喵子的静静的小角落">
<meta property="og:type" content="website">
<meta property="og:title" content="克里喵子">
<meta property="og:url" content="https://koorimeo.gitee.io/">
<meta property="og:site_name" content="克里喵子">
<meta property="og:description" content="一个属于克里喵子的静静的小角落">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Koori">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://koorimeo.gitee.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>克里喵子</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">克里喵子</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">克里喵子的小角落</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Koori</p>
  <div class="site-description" itemprop="description">一个属于克里喵子的静静的小角落</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2020/12/25/853df623c983/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/25/853df623c983/" class="post-title-link" itemprop="url">小米盒子4SE去广告战斗记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-25 13:22:45 / 修改时间：14:03:30" itemprop="dateCreated datePublished" datetime="2020-12-25T13:22:45+08:00">2020-12-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>新买了一个小米盒子4SE，本来觉得稍微有点广告也就忍忍罢了，可是万万想不到这盒子这么孙子……开机35秒广告，每次投屏25秒广告，而且电视版的app和手机版分开收费，同样是爱奇艺，手机平板的爱奇艺会员电视就看不了，的确让我感到无法接受，于是经过疯狂百度后，我找到了方法，分享一下：</p>
<ol>
<li>首先官网下载最新的安卓平台工具集<br><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/command-line/adb">https://developer.android.google.cn/studio/command-line/adb</a></li>
<li>小米盒子点 设置→关于→产品型号 多点几次，然后就会提示已经进入开发者模式。</li>
<li>然后就可以在 设置→账号与安全→ADB调试 中把选项改为允许。</li>
<li>之后点击设置→关于→网络设置，查看分配了哪个IP地址。</li>
<li>电脑解压平台工具然后运行命令提示符cd到平台工具集的文件夹里<br><code>adb connect 你的盒子ip地址</code><br>连接成功后，电视上会提示你有设备连接，选“允许”</li>
<li>adb devices 远程连接盒子</li>
<li>adb shell pm list package可以看盒子里都有哪些软件包的名称</li>
<li>通过adb uninstall –user 0 软件包名来删除，我都测试了一下，有如下这些都可以删除“精简”掉：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">软件包</th>
<th align="center">对应应用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">com.duokan.videodaily</td>
<td align="center">视频头条</td>
</tr>
<tr>
<td align="center">com.duokan.tvbox</td>
<td align="center">视频头条服务</td>
</tr>
<tr>
<td align="center">com.mipay.wallet.tv</td>
<td align="center">小米钱包</td>
</tr>
<tr>
<td align="center">com.xiaomi.smarthome.tv</td>
<td align="center">米家</td>
</tr>
<tr>
<td align="center">com.xiaomi.gamecenter.sdk.service.mibox</td>
<td align="center">游戏中心底层服务</td>
</tr>
<tr>
<td align="center">com.xiaomi.mibox.gamecenter</td>
<td align="center">游戏中心</td>
</tr>
<tr>
<td align="center">com.xiaomi.tweather</td>
<td align="center">天气预报</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.advertise</td>
<td align="center">广告服务</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.shop</td>
<td align="center">商城</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.appstore</td>
<td align="center">应用商店</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.payment</td>
<td align="center">支付</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.pay</td>
<td align="center">支付底层</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.calendar</td>
<td align="center">日历，删除后会黑屏一段时间，然后恢复正常</td>
</tr>
<tr>
<td align="center">com.xiaomi.mitv.upgrade</td>
<td align="center">电视盒子的更新程序，删除后有可能会让“设置”功能失效</td>
</tr>
</tbody></table>
<h3 id="注意事项和“小手段”"><a href="#注意事项和“小手段”" class="headerlink" title="注意事项和“小手段”"></a>注意事项和“小手段”</h3><ol>
<li>按住电源键重启后，adb会自动关闭，你就需要再到设置→账户与安全中重新把连接功能开开。</li>
<li>如果删错了黑了成了假砖，你可以拔了电源等10秒，然后插电源，按住遥控的HOME和菜单键，会出现recovery画面，后面的你就知道怎么做了。</li>
<li>删除掉upgrade之后“设置”会失去功能作用。但是！每次重启后的前5分钟左右它的功能是完全的，有充足的时间打开ADB</li>
<li>如果需要安装apk包，可以直接远程安装，命令是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install -r 盘符:\路径\软件包.apk</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2019/04/26/fcfbe8947ae4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/26/fcfbe8947ae4/" class="post-title-link" itemprop="url">ValueOf？toString？谁先谁后？？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-26 14:18:42" itemprop="dateCreated datePublished" datetime="2019-04-26T14:18:42+08:00">2019-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:20:53" itemprop="dateModified" datetime="2020-12-25T14:20:53+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A5%BD%E5%A5%87%E5%AE%B3%E6%AD%BB%E7%8C%AB/" itemprop="url" rel="index"><span itemprop="name">好奇害死猫</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>看到Number(Array(8))返回NaN之后我就觉得很好奇，[undefined,…]是一个数组，是个对象，对象一般都是先valueOf然后toString的。那么Number()在接收参数后按说执行到valueOf就会报错了。但是Number还是可以正常处理，难道是在这个过程中valueOf返回了自己的原值[undefined,…]之后自动执行了toString？这么智能么？又或者，Number接收到了数组，然后自动先执行了toString?</p>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>我找了一些朋友讨论了一下没有什么结果。于是我带着非常强烈的好奇心，想看看到底Number到底是怎么实现的。<br>搜索无果后我想到了ECMA262……</p>
<p>根据<a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/6.0/#sec-number-constructor-number-value">ECMA262</a>的说明，Number调用后会有一系列的抽象过程：</p>
<ol>
<li>如果没有参数传入，设置n为+0</li>
<li>如果有参数则设置n为ToNumber(value)</li>
<li>ReturnIfAbrupt(n)</li>
<li>如果返回的新值是undefined，返回n本身</li>
<li>设置O为OrdinaryCreateFromConstructor(新值, “%NumberPrototype%”, «[[NumberData]]»)</li>
<li>ReturnIfAbrupt(O)</li>
<li>设置O的[[NumberData]]内部“插槽”值为0</li>
<li>返回O</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以这么看，其实数组还是执行了valueOf之后被识别的，并没有再通过toString来获取字串。不过我大概明白了这么一些实现原理：</p>
<ol>
<li>Number(value)的value接收的不止是String类型，其实支持的是any这个类型，什么都可以。</li>
<li>基本上，除非类型为String（或者一些其它行为）使ToPrimitive(input, hint)的hint为’string’以外，直接访问对象的过程，默认都是通过valueOf返回自己的初值的过程。而数组作为object类型的对象，先执行valueOf，返回的就是[…]的这种形式的数据。当Number接收的是对象的时候并不会因为是对象进而内部“潜移默化”的执行toString的转换。</li>
<li>ECMAScript标准中每个基本类型都有一个原型，每个原型都有自己的一个内部“插槽”(<code>Internal Slots</code>)属性值。</li>
<li><code>Array</code>的内部“插槽”的值是按照<code>%ObjectPrototype%</code>来获取的，所以当数组为空的时候原型的内部“插槽”的值为null，相当于执行了Number(null)，抽象ToNumber(null)，查表可得+0，也就是0。</li>
<li>当数字只有一个元素的时候，其内部“插槽”的值是第0个元素，然后拆包，所以如果数组是[1]就相当于插槽是1，如果是[[[[[[[[[[[[[[[5]]]]]]]]]]]]]]]那么“插槽”值就是5。如果数组是[1,2,3]，那么拆包后就是1,2,3，那么“插槽”的值就是1,2,3[0]，也就是undefined。那么Number(undefined)的时候，抽象ToNumber(undefined)，查表可得<code>NaN</code></li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>通过这次对ECMA262的解读，我基本上了解了怎么阅读这份ES6标准，也明白了如何去理解各个API底层的原理——虽然可能和自己的工作并不相关吧……另外我觉得我更能理解浏览器为什么标准都不同这个道理了。其实你在ES6标准中根本就找不到什么通用浏览器API，它就是一个非常庞大的范式集合，可能这个集合标准更适合的是给大家自己做浏览器用吧……你也可以知道为什么浏览器之间标准不同，也可以明白为啥有的浏览器的API有这些，另一些却没有。收获还算是蛮大的……</p>
<p>为了能理解这些过程，我翻译了每一个涉及到的抽象概念的范式定义。如果你有兴趣，可以通过以下涉及到的范式概念来从根本上了解这个过程是怎么回事。</p>
<h2 id="附录：范式定义总结"><a href="#附录：范式定义总结" class="headerlink" title="附录：范式定义总结"></a>附录：范式定义总结</h2><h3 id="OrdinaryCreateFromConstructor-constructor-intrinsicDefaultProto-internalSlotsList"><a href="#OrdinaryCreateFromConstructor-constructor-intrinsicDefaultProto-internalSlotsList" class="headerlink" title="OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto, internalSlotsList)"></a>OrdinaryCreateFromConstructor(constructor, intrinsicDefaultProto, internalSlotsList)</h3><p>OrdinaryCreateFromConstructor创建一个对象，如果这个对象存在，它的[[Prototype]]值将从构造函数的原型属性中获取。如果不存在，则将由intrinsicDefaultProto命名的内部函数作为[[Prototype]]。internalSlotsList是一个集必须被声明的名称和额外内部Slots的一个List。如果没有提供这个List，则会用一个空List取代。它的执行过程如下：</p>
<ol>
<li>Assert: IntrinsicDefaultProto是内部对象的名称字串。相应的对象必须为一个用于内部可用来作为对象的[[Prototype]]值。</li>
<li>设 proto 为GetPrototypeFromConstructor(constructor, intrinsicDefaultProto).</li>
<li>ReturnIfAbrupt(proto).</li>
<li>返回 ObjectCreate(proto, internalSlotsList)</li>
</ol>
<h3 id="ToNumber-argument"><a href="#ToNumber-argument" class="headerlink" title="ToNumber(argument)"></a>ToNumber(argument)</h3><p>将argument转换为Number值，转换表如下：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Undefined</td>
<td align="left">NaN</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="left">+0</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="left">如果是true返回1，否则返回0</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="left">返回原值</td>
</tr>
<tr>
<td align="center">String</td>
<td align="left">视具体情况</td>
</tr>
<tr>
<td align="center">Symbol</td>
<td align="left">抛出TypeError异常</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="left">应用以下步骤：1. 设primValue为ToPrimitive(argument, hint). 2. 返回ToNumber(primValue)</td>
</tr>
<tr>
<td align="center">Completion Record</td>
<td align="left">如果argument是一个中断(abrupt completion)值返回argument自身。否则返回ToNumber(argument.[[value]])</td>
</tr>
</tbody></table>
<h3 id="ToPrimitive-input-PreferredType"><a href="#ToPrimitive-input-PreferredType" class="headerlink" title="ToPrimitive(input[, PreferredType])"></a>ToPrimitive(input[, PreferredType])</h3><table>
<thead>
<tr>
<th align="center">输入类型</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Completion Record</td>
<td align="left">如果input是一个中断(abrupt completion)则返回input本身，否则返回ToPrimitive(input.[[value]])且传送额外PreferredType</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="left">返回input</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="left">返回input</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="left">返回input</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="left">返回input</td>
</tr>
<tr>
<td align="center">String</td>
<td align="left">返回input</td>
</tr>
<tr>
<td align="center">Symbol</td>
<td align="left">返回input</td>
</tr>
</tbody></table>
<p>当input类型是Object，则经过以下步骤判断返回内容：</p>
<ol>
<li>如果没有PreferredType，则设置hint为默认值”default”</li>
<li>如果PreferredType是文本，则设置hint为”string”</li>
<li>如果PreferredType是数字，则设置hint为”number”</li>
<li>设置exoticToPrim为GetMethod(input, @@toPrimitive)</li>
<li>ReturnIfAbrupt(exoticToPrim)</li>
<li>如果exoticToPrim不是undefined,则<ol>
<li>设result为Call(exoticToPrim, input, «hint»)</li>
<li>ReturnIfAbrupt(result)</li>
<li>如果Type(result)不是对象，则返回result自己</li>
<li>否则抛出TypeError异常</li>
</ol>
</li>
<li>如果hint为”default”,则改hint值为”number”</li>
<li>返回OrdinaryToPrimitive(input, hint)</li>
</ol>
<p>当OrdinaryToPrimitive通过O和hint调用，则会通过以下步骤执行：</p>
<ol>
<li>Assert: Type(O)是Object</li>
<li>Assert: Type(hint)是String且只能是”string”或”number”.</li>
<li>如果hint是”string”，则设 methodName 为 «”toString”,”valueOf”»</li>
<li>否则设 method 为 «”valueOf”, “toString”»</li>
<li>遍历列表的每一个methodNames<ol>
<li>设method为Get(O, name)</li>
<li>ReturnIfAbrupt(method)</li>
<li>如果IsCallable(method)为true，则<ol>
<li>设result为Call(method, O)</li>
<li>ReturnIfAbrupt(method)</li>
<li>如果Type(result)不是Object,返回result</li>
</ol>
</li>
</ol>
</li>
<li>其它情况一律抛出TypeError异常</li>
</ol>
<p><strong>@@toPrimitive</strong>：没有hint的情况下通常目标input会优先判断为number，通过@@toPrimitive可以将Date对象和Symbol对象的ToPrimitive覆盖为自己的定义。当hint为字串时，Date对象不会对其处理。</p>
<h3 id="Completion-Record-完成记录"><a href="#Completion-Record-完成记录" class="headerlink" title="Completion Record - 完成记录"></a>Completion Record - 完成记录</h3><p>完成记录（Completion Record）值是一种用来表示运行时环境下数值与控制流的传播（比如break, continue, return和throw等）的表示方式，它包含3列内容：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">数值</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[[type]]</td>
<td align="center">normal, break, continue, return, throw之中的一个</td>
<td align="left">表示当前完成状态</td>
</tr>
<tr>
<td align="center">[[value]]</td>
<td align="center">空值（empty）或任意ECMAScript语言的值</td>
<td align="left">表示创建出来的值</td>
</tr>
<tr>
<td align="center">[[target]]</td>
<td align="center">空值（empty）或任意ECMAScript字串</td>
<td align="left">表示直接传递控制信息的标签</td>
</tr>
</tbody></table>
<h3 id="ReturnIfAbrupt"><a href="#ReturnIfAbrupt" class="headerlink" title="ReturnIfAbrupt"></a>ReturnIfAbrupt</h3><p>ReturnIfAbrupt是一个算法阶段，表示为ReturnIfAbrupt(argument),表示argument如果是一个中断值返回argument，或者是一条完成记录(Completion Record)</p>
<h3 id="Get-O-P"><a href="#Get-O-P" class="headerlink" title="Get(O,P)"></a>Get(O,P)</h3><p>Get用于获取目标对象特定属性的值，O代表对象，P代表属性，是属性的键名。它的执行过程是这样的：</p>
<ol>
<li>Assert: Type(O)是Object</li>
<li>Assert: IsPropertyKey(P)为true</li>
<li>返回 O.[[Get]](P,O)</li>
</ol>
<h3 id="GetMethod-O-P"><a href="#GetMethod-O-P" class="headerlink" title="GetMethod(O,P)"></a>GetMethod(O,P)</h3><p>GetMethod用于获取目标对象的特定属性值，这个属性值必须是函数。它的执行过程是这样的：</p>
<ol>
<li>Assert: IsPropertyKey(P)为true</li>
<li>设func 为GetV(O,P)</li>
<li>ReturnIfAbrupt(func)</li>
<li>如果func为undefine或null则统一返回undefined</li>
<li>如果 IsCallable(func)为false，抛出TypeError异常</li>
<li>返回 func</li>
</ol>
<h3 id="GetV-V-P"><a href="#GetV-V-P" class="headerlink" title="GetV(V,P)"></a>GetV(V,P)</h3><p>GetV用于获取ECMAScript语言之的特定属性的值。如果这个值不是对象，则包装成相应的对象然后查找目标属性。V是值，P是属性。它的执行过程是这样的：</p>
<ol>
<li>Assert: IsPropertyKey(P)为true</li>
<li>设O为ToObject(V)</li>
<li>ReturnIfAbrupt(O)</li>
<li>返回 O.[[Get]](P,V)</li>
</ol>
<p>IsPropertyKey(argument)<br>用于查看argument是否可以作为属性键名来用的值。这个argument必须符合ECMAScript语言的值或完成记录值。</p>
<ol>
<li>ReturnIfAbrupt(argument)</li>
<li>如果Type(argument)是String，返回true</li>
<li>如果Type(argument)是Symbol，返回true</li>
<li>返回false</li>
</ol>
<h3 id="ToObject-argument"><a href="#ToObject-argument" class="headerlink" title="ToObject(argument)"></a>ToObject(argument)</h3><p>将argument转换为如下的一种对象：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Completion Record</td>
<td align="left">如果argument是一个中断值，返回argument，否则返回ToObject(argument.[[value]])</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="left">抛出TypeError异常</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="left">抛出TypeError异常</td>
</tr>
<tr>
<td align="center">Boolean</td>
<td align="left">返回一个新的Boolean(argument)对象</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="left">返回一个新的Number(argument)对象</td>
</tr>
<tr>
<td align="center">String</td>
<td align="left">返回一个新的String(argument)对象</td>
</tr>
<tr>
<td align="center">Symbol</td>
<td align="left">返回一个新的Symbol(argument)对象</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="left">返回argument自身</td>
</tr>
</tbody></table>
<h3 id="IsCallable-argument"><a href="#IsCallable-argument" class="headerlink" title="IsCallable(argument)"></a>IsCallable(argument)</h3><p>查看argument是否是可调用的函数，即带有[[Call]]这个内部方法。</p>
<ol>
<li>ReturnIfAbrupt(argument)</li>
<li>如果Type(argument)不是对象， 返回false</li>
<li>如果argument有[[Call]]这个内部方法，返回true</li>
<li>返回false</li>
</ol>
<h2 id="ECMAScript标准中一些范式的术语解析："><a href="#ECMAScript标准中一些范式的术语解析：" class="headerlink" title="ECMAScript标准中一些范式的术语解析："></a>ECMAScript标准中一些范式的术语解析：</h2><p>这些术语写的都特别像函数，所以有的时候看ECMAScript真的很费力……我列出了一些标准术语供大家参考，以免和我一样为了查一个原理要来回跳转那么次</p>
<table>
<thead>
<tr>
<th align="center">术语</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Assert:</td>
<td align="left">设置断言，就是普通的assert</td>
</tr>
<tr>
<td align="center">Type(目标)</td>
<td align="left">检查目标的（运行时）类型。比如Type(x)表示”the type of x”</td>
</tr>
<tr>
<td align="center">List</td>
<td align="left">List，列表，用于表示一种表达式中有序的参数列表。这些列表的元素一般通过标准助记符号解释。</td>
</tr>
<tr>
<td align="center">arguments</td>
<td align="left">表示列表中的各元素，即”List arguments”。注意如果argument有下标，则表示第n+1个参数，比如arguments[<code>2</code>]就表示第<code>3</code>个参数</td>
</tr>
<tr>
<td align="center">%NumberPrototype%</td>
<td align="left">相当于Number.prototype。是Number原型的固有对象。该对象包含这些属性： {[[Writable]]:false, [[Enumerable]]:false, [[Configurable]]:false}</td>
</tr>
<tr>
<td align="center">%ArrayPrototype%</td>
<td align="left">相当于Array.prototype。是Array原型的固有对象。该对象包含这些属性： {[[Writable]]:false, [[Enumerable]]:false, [[Configurable]]:false}</td>
</tr>
</tbody></table>
<h2 id="ECMAScript的助记符号："><a href="#ECMAScript的助记符号：" class="headerlink" title="ECMAScript的助记符号："></a>ECMAScript的助记符号：</h2><p>这也是很多人看不明白到底这些都是干什么的，其实都是为了方便书写规范或者帮助人们理解概念而设置的符号。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">«»</td>
<td align="left">列表符号。通过语义的方式表达一个列表中的各个元素值。例如«a,b»即表示一个包含a元素和b元素的列表</td>
</tr>
<tr>
<td align="center">[[]]</td>
<td align="left">记录符号。描述算法中的数据聚合。通过[[]]表示的值要么是ECMAScript的值，要么是与记录内容的类型相关联的值，比如[[value]]这种写法就相当于是表示这里是目标的一个值</td>
</tr>
<tr>
<td align="center">[[]]:n</td>
<td align="left">对象语法符号。特定值记录符号，通过对象文字的语义记录值。比如[[field1]]:42, [[field2]]:false, [[field3]]:empty 则表示这是一个包含三个字段的值。需要注意如果没有标明值，则表示这个字段实际上不存在</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">表示引用字段的记录值。比如R是上一步中获得的记录，则R.[[field2]]表示“R中名为[[field2]]的字段”</td>
</tr>
<tr>
<td align="center">常见名</td>
<td align="left">这个最坑，名称不一定，但是表示常用记录字段，一般会标识正在描述的特定类型的一种聚合。 比如 PropertyDescriptor[[value]]:42, [[Writable]]:false, [[Configurable]]:true等……</td>
</tr>
</tbody></table>
<h2 id="关于对象的内部方法及“插槽”————Internal-Methods-Slots"><a href="#关于对象的内部方法及“插槽”————Internal-Methods-Slots" class="headerlink" title="关于对象的内部方法及“插槽”————Internal Methods / Slots"></a>关于对象的内部方法及“插槽”————Internal Methods / Slots</h2><p>在ECMAScript中， 对象的实际语义是通过内部方法的算法过程来指定的。 ECMAScript引擎中的每一个对象都与一组运行时环境定义的内部方法相关联。它们并不属于ECMAScript的一部分，但是ECMAScript语言要求每个对象的实现都要指定其内部拥有一个完整的与之关联的方法集。</p>
<p>内部方法(Internal Methods)是多态的。即党对不同的对象调用通用内部方法时可以执行对应的不同的算法。调用内部方法的实际目的是调用到对应的“target”。在运行时环境下，如果你要实现的算法其内部不支持，那么就会抛出TypeError异常。</p>
<p>内部“插槽”(Internal Slots)对应与对象关联的内部的状态。它们不是对象的属性，而是由ECMAScript语言类型或特定类型的值来构成，所以不会被继承。除非另有明确的要求，否则内部“插槽”将作为创建对象过程的一部分来分配，不能动态添加到对象中，通常构建时其值应该为Undefined。</p>
<p>一般情况下ECMAScript规定每个对象都有自己的基本内部方法，但是所有对象不一定对这些方法都使用相同的算法。</p>
<p>主要内部方法应该包含如下一些：</p>
<table>
<thead>
<tr>
<th align="center">内部方法</th>
<th align="center">验证</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[[GetPrototypeOf]]</td>
<td align="center">()→ Object 丨 Null</td>
<td align="left">区分对象是否有继承的属性。 null值标识没有继承的属性</td>
</tr>
<tr>
<td align="center">[[SetPrototypeOf]]</td>
<td align="center">(Object 丨Null )→ Boolean</td>
<td align="left">将this与Object进行关联检查以继承Object的属性，成功返回true，失败返回false，无可继承属性返回null</td>
</tr>
<tr>
<td align="center">[[IsExtensible]]</td>
<td align="center">()→Boolean</td>
<td align="left">检查是否允许为对象增加额外的属性</td>
</tr>
<tr>
<td align="center">[[PreventExtensions]]</td>
<td align="center">()→Boolean</td>
<td align="left">控制新属性是否可以添加到对象中</td>
</tr>
<tr>
<td align="center">[[GetOwnProperty]]</td>
<td align="center">(propertyKey)→Undefined丨Property Descriptor</td>
<td align="left">返回自己的一个属性描述符（Property Descriptor），propertyKey就是属性的键名，如果没有此属性，返回undefined</td>
</tr>
<tr>
<td align="center">[[HasProperty]]</td>
<td align="center">(propertyKey)→Boolean</td>
<td align="left">返回对象中是否存在目标属性键名propertyKey</td>
</tr>
<tr>
<td align="center">[[Get]]</td>
<td align="center">(propertyKey, Receiver)→ any</td>
<td align="left">返回对象中键名为propertyKey的值。如果值为ECMAScript代码，则该代码将被执行以获取最终计算结果的取值。Receiver用来在执行代码时指定this</td>
</tr>
<tr>
<td align="center">[[Set]]</td>
<td align="center">(propertyKey, value, Receiver)→ Boolean</td>
<td align="left">为属性键名propertyKey设置一个值value。如果value为ECMAScript代码，则该代码将被执行以获取最终计算结果的取值。Receiver用来在执行代码时指定this</td>
</tr>
<tr>
<td align="center">[[Delete]]</td>
<td align="center">(propertyKey)→Boolean</td>
<td align="left">从对象中去掉指定键名的属性。如果操作后属性依旧存在，或者未能删除的，返回false，否则返回true</td>
</tr>
<tr>
<td align="center">[[DefineOwnProperty]]</td>
<td align="center">(propertyKey, PropertyDescriptor)→Boolean</td>
<td align="left">创建或修改自己的属性，propertyKey是键名，状态描述为PropertyDescriptor属性描述符。如果修改/创建成功，返回true，否则返回false</td>
</tr>
<tr>
<td align="center">[[Enumerate]]</td>
<td align="center">()→Object</td>
<td align="left">返回一个迭代器对象，生成可供枚举的键字串</td>
</tr>
<tr>
<td align="center">[[OwnPropertyKeys]]</td>
<td align="center">()→List of propertyKey</td>
<td align="left">返回自己所有属性键名的列表</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">内部方法</th>
<th align="center">验证</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[[Call]]</td>
<td align="center">(any, a List of any)→ any</td>
<td align="left">通过函数表达式调用与自己关联的代码。参数为this和所有需要传递进来的参数List。要成功调用此内部方法必须先实现这个内部方法，且这个对象必须为<strong>callable</strong></td>
</tr>
<tr>
<td align="center">[[Construct]]</td>
<td align="center">(a List of any, Object)→ Object</td>
<td align="left">通过<strong>new</strong>或<strong>super</strong>操作符创建一个对象。第一个参数是包含运算符参数的列表。第二个参数是最初应用新运算符的对象。实现这个内部方法的对象即为“构造函数”。一个函数对象不一定就是构造函数，它有可能是不具有[[Construct]]内部方法的对象。</td>
</tr>
</tbody></table>
<h1 id="数组的构造函数"><a href="#数组的构造函数" class="headerlink" title="数组的构造函数"></a>数组的构造函数</h1><p>数组的构造函数就是%Array%固有的对象，其初值便是全局变量的Array原型。不论是被用作构造函数还是一般的函数调用，它都会创建一个外部的Array对象。因此函数调用<code>Array(...)</code>是等价于对象构建表达式<code>new Array(...)</code>的（参数一致的前提下）。</p>
<p>数组的构造函数是一个可以继承的，并且可以根据参数数量与类型进行重载的函数。因此它可以通过<code>extends</code>关键字在定义类时派生。子类属于Array的一个外部对象，其构造函数必须通过<code>super</code>来获取Array的构造函数才能将子类的实例初始化为一个Array对象。Array.protype方法多是通用的，并不依赖于其外部对象的this。</p>
<h1 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h1><p>返回 ToObject(<code>this</code>)</p>
<h1 id="Boolean-prototype-valueOf"><a href="#Boolean-prototype-valueOf" class="headerlink" title="Boolean.prototype.valueOf()"></a>Boolean.prototype.valueOf()</h1><p>返回 thisBooleanValue(<code>this</code>)</p>
<h1 id="Symbol-prototype-valueOf"><a href="#Symbol-prototype-valueOf" class="headerlink" title="Symbol.prototype.valueOf()"></a>Symbol.prototype.valueOf()</h1><ol>
<li>设s为<code>this</code></li>
<li>如果Type(s)是Symbol，返回s</li>
<li>如果Type(s)不是Object，抛出TypeError异常</li>
<li>如果s没有[[SymbolData]]内部“插槽”，抛出TypeError异常</li>
<li>返回s的[[SymbolData]]内部“插槽”</li>
</ol>
<h1 id="Number-prototype-valueOf"><a href="#Number-prototype-valueOf" class="headerlink" title="Number.prototype.valueOf()"></a>Number.prototype.valueOf()</h1><ol>
<li>设x为 thisNumberValue(this)</li>
<li>返回x</li>
</ol>
<h1 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h1><p>返回this的time值，该值为Number类型</p>
<h1 id="String-prototype-valueOf"><a href="#String-prototype-valueOf" class="headerlink" title="String.prototype.valueOf()"></a>String.prototype.valueOf()</h1><ol>
<li>设s为thisStringValue(this)</li>
<li>返回s</li>
</ol>
<h1 id="this-Boolean-Number-String-Value-value"><a href="#this-Boolean-Number-String-Value-value" class="headerlink" title="this(Boolean|Number|String)Value(value)"></a>this(Boolean|Number|String)Value(value)</h1><p>就是一种抽象过程，以thisBooleanValue为例，过程为：</p>
<ol>
<li>如果Type(value)是Boolean，返回value</li>
<li>如果Type(value)是Object且Value有[[BooleanData]]内部“插槽”，则：<ol>
<li>Assert: value的[[BooleanData]]内部“插槽”的值是Boolean类型的值</li>
<li>返回value的[[BooleanData]]内部“插槽”的值</li>
</ol>
</li>
<li>抛出TypeError异常</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2019/04/26/0cb9e07071b2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/26/0cb9e07071b2/" class="post-title-link" itemprop="url">Javascript的那些基础小坑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-26 14:04:46" itemprop="dateCreated datePublished" datetime="2019-04-26T14:04:46+08:00">2019-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:13:11" itemprop="dateModified" datetime="2020-12-25T14:13:11+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Javascript/" itemprop="url" rel="index"><span itemprop="name">Javascript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>JS本没坑，代码码多了，也就多出来了好多坑……</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>生成<code>Boolean</code>对象有几处值是需要牢记的，否则会出很多“意料之外”的结果：</p>
<table>
<thead>
<tr>
<th align="center">语句</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean([])</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">Boolean(undefined)</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">Boolean(0)</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">Boolean(NaN)</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">Boolean(‘’)</td>
<td align="center">false</td>
</tr>
</tbody></table>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>生成<code>Number</code>对象也有几处值需要牢记，这都挺有意思的</p>
<table>
<thead>
<tr>
<th align="center">语句</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Number(false)</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Number(true)</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Number({})</td>
<td align="center">NaN</td>
</tr>
</tbody></table>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><code>Array</code>我总觉得不太常用，一般都是用let a = []来指定内容的情况可能会多一些，不过有些情况下——比如<code>初始化一个超大的数组</code>的时候——可能使用<code>Array()</code>/<code>new Array()</code>会好一些吧。至于<code>Array()</code>和<code>new Array()</code>的不同，好像是<code>new Array</code>在<code>Array</code>基础之上多加了一层对象包裹，内容比Array()显得冗余，但是语法更规范，符合对象的集成概念……不过不用这么纠结，使用的时候还是看自己的习惯好了。</p>
<p>最基础的，用<code>Array</code>生成一个数组的时候如果只给定一个参数，则生成对应的长度并以<code>undefined</code>填充；如果有两个或多个参数则每个参数都作为<code>元素</code>填充在数组中。</p>
<hr>
<p>更多坑还会一点点更新……吗？=_,=|||</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/12/20/5f7f158f21bd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/20/5f7f158f21bd/" class="post-title-link" itemprop="url">webpack-dev-server 指令说明书</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-20 14:21:54" itemprop="dateCreated datePublished" datetime="2018-12-20T14:21:54+08:00">2018-12-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:22:37" itemprop="dateModified" datetime="2020-12-25T14:22:37+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">文档翻译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇应该是webpack-dev-server最全面的说明书了……Orz</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 布尔值默认为null是什么鬼？!……还有--lazy Lazy是啥？！</span><br><span class="line">- 可能，这就是javascript吧……</span><br><span class="line"></span><br><span class="line">　　　　　　——2018年12月20日的一次对话……</span><br></pre></td></tr></table></figure>
<p><code>webpack-dev-server</code>是利用用webpack建立一个开发服务器以提供内容的实时重载功能。此命令应该仅用于开发环境。<br>它也可以通过底层使用webpack-dev-middleware以实现在内存中处理webpack的资源。</p>
<p>我在这里罗列了webpack-dev-server的<strong>全部</strong>参数选项，并同样也按功能做了分类。<br>可以这么说,webpack-dev-server的这些丰富的参数是一种对不同习惯人群的示好，展现了很好的包容力。值得花时间看看，熟悉更多的用法。</p>
<hr>
<h3 id="配置选项："><a href="#配置选项：" class="headerlink" title="配置选项："></a>配置选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–config</td>
<td align="center">字串</td>
<td align="center">指定config文件所在路径。默认值：<code>webpack.config.js</code> 或 <code>webpackfile.js</code></td>
</tr>
<tr>
<td align="center">–config-register, -r</td>
<td align="center">数组</td>
<td align="center">加载webpack配置前预加载一个或以上的模块。默认值：模块的id或路径</td>
</tr>
<tr>
<td align="center">–config-name</td>
<td align="center">字串</td>
<td align="center">指定使用的配置名称</td>
</tr>
<tr>
<td align="center">–env</td>
<td align="center">字串</td>
<td align="center">向配置内容传递环境参数，仅限以下三个值：”development”, “production”, “none”</td>
</tr>
<tr>
<td align="center">–mode</td>
<td align="center">字串</td>
<td align="center">启用生产环境的优化或开发提示，仅限以下三个值：”development”, “production”, “none”</td>
</tr>
</tbody></table>
<h3 id="基本选项："><a href="#基本选项：" class="headerlink" title="基本选项："></a>基本选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–context</td>
<td align="center">字串</td>
<td align="center">解析<code>entry</code>选项的最顶层文件夹。这是一个绝对路径。如果设置了<code>output.pathinfo</code>，则pathinfo改为这个路径。默认路径为当前文件夹</td>
</tr>
<tr>
<td align="center">–entry</td>
<td align="center">字串</td>
<td align="center">为编译行为指定入口点</td>
</tr>
<tr>
<td align="center">–watch, -w</td>
<td align="center">布尔值</td>
<td align="center">进入观察者模式，即当文件变动时重新执行生成</td>
</tr>
<tr>
<td align="center">–debug</td>
<td align="center">布尔值</td>
<td align="center">切换各loader进入debug模式</td>
</tr>
<tr>
<td align="center">–devtool</td>
<td align="center">字串</td>
<td align="center">一个增强debug功能的开发工具</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">布尔值</td>
<td align="center">使用这个选项表示同时指定了 <code>--debug</code>、<code>--devtool</code>、<code>--eval-cheap-module-source-map</code>和<code>--output-pathinfo</code>这四个选项</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="center">布尔值</td>
<td align="center">使用这个选项表示同时指定了 <code>--optimize-minimize</code>、<code>--define</code>和<code>process.env.NODE_ENV=&quot;production&quot;</code></td>
</tr>
<tr>
<td align="center">–progress</td>
<td align="center">布尔值</td>
<td align="center">打印一个便宜进度信息</td>
</tr>
</tbody></table>
<h3 id="模块选项："><a href="#模块选项：" class="headerlink" title="模块选项："></a>模块选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–module-bind</td>
<td align="center">字串</td>
<td align="center">给loader绑定扩展</td>
</tr>
<tr>
<td align="center">–module-bind-post</td>
<td align="center">字串</td>
<td align="center">给已用的loader绑定扩展</td>
</tr>
<tr>
<td align="center">–module-bind-pre</td>
<td align="center">字串</td>
<td align="center">给预置的loader绑定扩展</td>
</tr>
</tbody></table>
<h3 id="输出选项："><a href="#输出选项：" class="headerlink" title="输出选项："></a>输出选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–output, -o</td>
<td align="center">字串</td>
<td align="center">指定出口路径和参与编译的文件</td>
</tr>
<tr>
<td align="center">–output-path</td>
<td align="center">字串</td>
<td align="center">指定出口文件夹路径，必须为<strong>绝对路径</strong> 默认值：当前文件夹</td>
</tr>
<tr>
<td align="center">–output-filename</td>
<td align="center">字串</td>
<td align="center">指定每个输出到磁盘文件的名字。绝对<strong>不要</strong>在这里设置绝对路径！<code>output.path</code>选项将辨别文件的位置并为文件取一个唯一的文件名。默认值： [name].js</td>
</tr>
<tr>
<td align="center">–output-chunk-filename</td>
<td align="center">字串</td>
<td align="center"><code>output.path</code>的相对路径中的非入口区块文件名。默认值： 文件名+[id]</td>
</tr>
<tr>
<td align="center">–output-source-map-filename</td>
<td align="center">字串</td>
<td align="center"><code>output.path</code>中JavaScript文件的SourceMaps文件名。</td>
</tr>
<tr>
<td align="center">–output-public-path</td>
<td align="center">字串</td>
<td align="center"><code>publicPath</code>指定了文件被浏览器引用时所在的公开URL位置</td>
</tr>
<tr>
<td align="center">–output-jsonp-function</td>
<td align="center">字串</td>
<td align="center">wepack为了同步载入区块而使用的JSONP函数</td>
</tr>
<tr>
<td align="center">–output-pathinfo</td>
<td align="center">布尔值</td>
<td align="center">决定是否在编译时加入模块相关的注释</td>
</tr>
<tr>
<td align="center">–output-library</td>
<td align="center">字串</td>
<td align="center">将入口节点作为公开的库文件</td>
</tr>
<tr>
<td align="center">–output-library-target</td>
<td align="center">字串</td>
<td align="center">指定库的类型。可选值分别为：”var”, “assign”, “this”, “window”, “self”, “global”, “commonjs”, “commonjs2”, “commonjs-module”, “amd”, “umd”, “umd2”, “jsonp”</td>
</tr>
</tbody></table>
<h3 id="高级选项："><a href="#高级选项：" class="headerlink" title="高级选项："></a>高级选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–records-input-path</td>
<td align="center">字串</td>
<td align="center">将编译状态保存到json文件</td>
</tr>
<tr>
<td align="center">–records-output-path</td>
<td align="center">字串</td>
<td align="center">从json文件读取编译状态</td>
</tr>
<tr>
<td align="center">-records-path</td>
<td align="center">字串</td>
<td align="center">指定向/从json文件中存储或载入编译状态的<code>绝对路径</code>。这个参数指定了<code>recpordsPath</code>的内容，如果没有指定<code>recordsInputPath</code>或<code>recordsOutputPath</code>就会用它来做替代</td>
</tr>
<tr>
<td align="center">–define</td>
<td align="center">字串</td>
<td align="center">在bundle定义一个自由变量</td>
</tr>
<tr>
<td align="center">–target</td>
<td align="center">字串</td>
<td align="center">设置构建环境</td>
</tr>
<tr>
<td align="center">–cache</td>
<td align="center">布尔值</td>
<td align="center">是否设置提高多重增量构建性能的模块与区块的缓存</td>
</tr>
<tr>
<td align="center">–watch-sdin, –stdin</td>
<td align="center">布尔</td>
<td align="center">是否在标准输入流结束后自动关闭</td>
</tr>
<tr>
<td align="center">–watch-aggregate-timeout</td>
<td align="center">数字</td>
<td align="center">设置首次变更后重新生成的延迟时间。单位：毫秒</td>
</tr>
<tr>
<td align="center">–watch-poll</td>
<td align="center">字串</td>
<td align="center">启用轮询监视</td>
</tr>
<tr>
<td align="center">–hot</td>
<td align="center">布尔值</td>
<td align="center">启用模块热替换功能</td>
</tr>
<tr>
<td align="center">–prefetc</td>
<td align="center">字串</td>
<td align="center">预抓取目标请求 (例如： –prefetch)</td>
</tr>
<tr>
<td align="center">–provide</td>
<td align="center">字串</td>
<td align="center">为所有模块提供一个自由变量 (例如： –provide JQuery=jquery)</td>
</tr>
<tr>
<td align="center">–labeled-modules</td>
<td align="center">布尔值</td>
<td align="center">启用模块标注</td>
</tr>
<tr>
<td align="center">–plugin</td>
<td align="center">字串</td>
<td align="center">载入指定的模块</td>
</tr>
<tr>
<td align="center">–bail</td>
<td align="center">布尔值</td>
<td align="center">对错误信息采用零容忍策略。默认值: null</td>
</tr>
<tr>
<td align="center">–profile</td>
<td align="center">布尔值</td>
<td align="center">为每一个模块设置捕获定时信息。　默认值: null</td>
</tr>
<tr>
<td align="center">–hot-only</td>
<td align="center">布尔值</td>
<td align="center">如果模块热替换失败就不刷新页面</td>
</tr>
</tbody></table>
<h3 id="解析选项："><a href="#解析选项：" class="headerlink" title="解析选项："></a>解析选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–resolve-alias</td>
<td align="center">字串</td>
<td align="center">重定向模块请求</td>
</tr>
<tr>
<td align="center">–resolve-exensions</td>
<td align="center">数组</td>
<td align="center">重定向模块请求</td>
</tr>
<tr>
<td align="center">–resolve-loader-alias</td>
<td align="center">字串</td>
<td align="center">为loader的解析过程设置别名</td>
</tr>
</tbody></table>
<h3 id="优化选项："><a href="#优化选项：" class="headerlink" title="优化选项："></a>优化选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–optimize-max-chunks</td>
<td align="center">数字</td>
<td align="center">将会尝试保持区块计数值低于限定值</td>
</tr>
<tr>
<td align="center">–optimize-min-chunk-size</td>
<td align="center">数字</td>
<td align="center">创建区块的最低尺寸条件</td>
</tr>
<tr>
<td align="center">–optimize-minimize</td>
<td align="center">布尔值</td>
<td align="center">启用输出最小化策略。会用到<code>optimization.minimmizer</code></td>
</tr>
</tbody></table>
<h3 id="状态选项："><a href="#状态选项：" class="headerlink" title="状态选项："></a>状态选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–color, –colors</td>
<td align="center">布尔值</td>
<td align="center">启用或禁用终端配色输出方案</td>
</tr>
<tr>
<td align="center">–info</td>
<td align="center">布尔值</td>
<td align="center">输出webpack-dev-server运行细节。　默认值：true</td>
</tr>
<tr>
<td align="center">–client-log-level</td>
<td align="center">字串</td>
<td align="center">设置日志输出等级。可选值有<code>info</code>, <code>warning</code>, <code>error</code>和<code>none</code>。默认值：info</td>
</tr>
</tbody></table>
<h3 id="SSL选项："><a href="#SSL选项：" class="headerlink" title="SSL选项："></a>SSL选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–https</td>
<td align="center">布尔值</td>
<td align="center">是否启用HTTPS</td>
</tr>
<tr>
<td align="center">–key</td>
<td align="center">字串</td>
<td align="center">指定SSL秘钥的位置</td>
</tr>
<tr>
<td align="center">–cert</td>
<td align="center">字串</td>
<td align="center">指定SSL证书的位置</td>
</tr>
<tr>
<td align="center">–cacert</td>
<td align="center">字串</td>
<td align="center">指定CA证书的位置</td>
</tr>
<tr>
<td align="center">–pfx</td>
<td align="center">字串</td>
<td align="center">指定SSL pfx证书的位置</td>
</tr>
<tr>
<td align="center">–pfx-passphrase</td>
<td align="center">字串</td>
<td align="center">pfx证书密码</td>
</tr>
</tbody></table>
<h3 id="响应选项："><a href="#响应选项：" class="headerlink" title="响应选项："></a>响应选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–content-base</td>
<td align="center">字串</td>
<td align="center">指定HTML服务的目录</td>
</tr>
<tr>
<td align="center">–watch-content-base</td>
<td align="center">布尔值</td>
<td align="center">启用实时重载</td>
</tr>
<tr>
<td align="center">–history-api-fallback</td>
<td align="center">布尔值</td>
<td align="center">从单页面应用退回/index.html</td>
</tr>
<tr>
<td align="center">–compress</td>
<td align="center">布尔值</td>
<td align="center">启用gzip压缩</td>
</tr>
</tbody></table>
<h3 id="连接选项："><a href="#连接选项：" class="headerlink" title="连接选项："></a>连接选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–port</td>
<td align="center">数字</td>
<td align="center">指定端口号</td>
</tr>
<tr>
<td align="center">–disable-host-check</td>
<td align="center">布尔值</td>
<td align="center">设置是否检查主机</td>
</tr>
<tr>
<td align="center">–socker</td>
<td align="center">任意</td>
<td align="center">指定监听的Socket文件</td>
</tr>
<tr>
<td align="center">–public</td>
<td align="center">字串</td>
<td align="center">服务器的主机名或IP地址</td>
</tr>
<tr>
<td align="center">–host</td>
<td align="center">字串</td>
<td align="center">服务器要绑定的主机名或IP地址。默认值：”localhost”</td>
</tr>
<tr>
<td align="center">–alowed-hosts</td>
<td align="center">字串</td>
<td align="center">许可访问开发主机的主机名列表，主机名间用(半角)逗号分隔</td>
</tr>
</tbody></table>
<h3 id="其它选项："><a href="#其它选项：" class="headerlink" title="其它选项："></a>其它选项：</h3><table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–help, -h</td>
<td align="center">无</td>
<td align="center">显示这段帮助信息</td>
</tr>
<tr>
<td align="center">–version</td>
<td align="center">无</td>
<td align="center">显示当前webpack-dev-server的版本</td>
</tr>
<tr>
<td align="center">–bonjour</td>
<td align="center">无</td>
<td align="center">通过ZeroConf网络广播服务器信息</td>
</tr>
<tr>
<td align="center">–lazy</td>
<td align="center">无</td>
<td align="center">字如其意</td>
</tr>
<tr>
<td align="center">–inline</td>
<td align="center">布尔值</td>
<td align="center">是否启用内联模式，若为false则不启用客户端脚本的功能（比如：实时重载）。默认值: true</td>
</tr>
<tr>
<td align="center">–open</td>
<td align="center">字串</td>
<td align="center">打开默认浏览器，也可以后面跟字串打开指定的浏览器</td>
</tr>
<tr>
<td align="center">–useLocalIp</td>
<td align="center">布尔值</td>
<td align="center">打开默认浏览器访问本机IP</td>
</tr>
<tr>
<td align="center">–open-page</td>
<td align="center">字串</td>
<td align="center">打开浏览器访问指定页面</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/12/19/33d6387e61ce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/12/19/33d6387e61ce/" class="post-title-link" itemprop="url">ncu升级后的注意事项</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-19 14:10:47" itemprop="dateCreated datePublished" datetime="2018-12-19T14:10:47+08:00">2018-12-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:11:31" itemprop="dateModified" datetime="2020-12-25T14:11:31+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新版本的ncu无参数时是告知你模块都更新到了哪个版本，只有使用ncu -u后才会写到package.json文件中</span><br></pre></td></tr></table></figure>
<h3 id="啰啰嗦嗦的文章"><a href="#啰啰嗦嗦的文章" class="headerlink" title="啰啰嗦嗦的文章"></a>啰啰嗦嗦的文章</h3><p>最近好久没有新博客文章了，主要是一直在忙着起草我的新项目：<br><a target="_blank" rel="noopener" href="https://github.com/Bedivere-Sun/write_react_project_from_scratch" title="请多指教">抽丝剥茧学前端之React篇</a>。<br>刚刚终于push到了仓库里。本来开始是想写一段总结的，后来发现有了这个话题，所以就把总结写在项目readme里了……哈哈哈哈哈……好聪明！</p>
<p>然后我就开始继续学习前端课程和写练习。</p>
<p>原先的习惯是通过<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/npm-check-updates">npm-check-updates</a>把package.json包中的版本更新然后跟新对应模块的。<br>今天得到提示说有升级，于是通过命令升级了ncu：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check-updates</span><br></pre></td></tr></table></figure>
<p>之后按照原来的习惯使用ncu命令更新配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu</span><br></pre></td></tr></table></figure>
<p>系统返回这个提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The following dependencies are satisfied by their declared version range, but the installed versions are behind. </span><br><span class="line">You can install the latest versions without modifying your package file by using npm update. </span><br><span class="line">If you want to update the dependencies in your package file anyway, run ncu -a.</span><br><span class="line"></span><br><span class="line"> less                     ^3.0.4  →   ^3.9.0 </span><br><span class="line"> moment                  ^2.22.2  →  ^2.23.0 </span><br><span class="line"> query-string             ^6.1.0  →   ^6.2.0 </span><br><span class="line"> react                   ^16.4.0  →  ^16.6.3 </span><br><span class="line"> react-dom               ^16.4.0  →  ^16.6.3 </span><br><span class="line"> webpack                  ^4.9.1  →  ^4.27.1 </span><br><span class="line"> webpack-dev-middleware   ^3.1.3  →   ^3.4.0 </span><br><span class="line"> webpack-dev-server       ^3.1.4  →  ^3.1.10 </span><br><span class="line"> webpack-hot-middleware  ^2.22.2  →  ^2.24.3 </span><br><span class="line"></span><br><span class="line">Run ncu with -u to upgrade package.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我当时没有注意，直接npm install然后npm run执行项目，结果项目报错了。我还以为自己哪里写错了，各种找，最后竟然还回退到了上一个版本，结果居然也是报错的</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ERROR in ./src/pages/Main/index.js</span><br><span class="line">Module build failed (from ./node_modules/_babel-loader@8.0.4@babel-loader/lib/index.js):</span><br><span class="line">Error: Cannot find module &#x27;@babel/core&#x27;</span><br><span class="line"> babel-loader@8 requires Babel 7.x (the package &#x27;@babel/core&#x27;). If you&#x27;d like to use Babel 6.x (&#x27;babel-core&#x27;), you should install &#x27;babel-loader@7&#x27;.</span><br><span class="line">    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:587:15)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:513:25)</span><br><span class="line">    at Module.require (internal/module</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>然后我就怀疑package.json这里会不会有问题，打开一看，依赖的模块版本居然全都没有升级……<br>于是我又重新使用ncu了一次，终于发现系统返回的提示里已经告诉我怎么回事了……Orz</p>
<blockquote>
<p>If you want to update the dependencies in your package file anyway, run ncu -a.<br>Run ncu with -u to upgrade package.json</p>
</blockquote>
<p>所以，从这次版本升级后，ncu要通过-u来修改package.json的内容了。<br>其实这样修改也是有好处的，毕竟有一些项目还是需要旧版本的模块的，模块一旦标为最新版本就可能出现各种问题。<br>所以这里一定要注意！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncu -u</span><br></pre></td></tr></table></figure>
<p>从今天开始，我决定在博客文章中加入“一句话总结”，把观点浓缩为一句话，以节省各位访客的宝贵时间。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/11/25/9b87243b8d15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/25/9b87243b8d15/" class="post-title-link" itemprop="url">浪潮AS1100H通过Windows客户端在CentOS7中的配置方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-25 13:49:29" itemprop="dateCreated datePublished" datetime="2018-11-25T13:49:29+08:00">2018-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:03:31" itemprop="dateModified" datetime="2020-12-25T14:03:31+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>标题有点绕……看完了你旧明白为啥标题这么蛋疼了……</p>
<p>第一次摸存储，大概了解了一些设置和配置的问题。这里做个小总结。<br>大致背景就是客户有个项目用存储保存大量的内容（其实只有500G，且最终数据量不会超过1.5TB……这个存储被之前的以为专家把22.5T全分出去了……汗……），然后我前任<br>的工程师离职了，估计他也忘记有这么个东西了，于是我完全不知情的情况下接到通知要求我去给客户做一组冷备主机，要求能和存储连接起来，然后方便后面厂商的人过来<br>搭对应的服务。于是我的存储之旅就开始了</p>
<p>我的这次学习经历答案主要来自百度(很多不靠谱的答案）、浪潮存储的客服（给予了一定的支持，不过后来好像我给他弄烦了……)和<a target="_blank" rel="noopener" href="https://github.com/Bedivere-Sun/man/blob/master/man5/multipath.conf">mutipath.conf(5)</a>…</p>
<h3 id="一些我记录的“知识点”"><a href="#一些我记录的“知识点”" class="headerlink" title="一些我记录的“知识点”"></a>一些我记录的“知识点”</h3><ol>
<li>存储一般是一个机头拉N个扩展柜主要区别是存储的机头主要用于将所有数据汇总，借口比扩展柜丰富。</li>
<li>机头的传输光纤与扩展柜的最后一组光纤连接即可，其它的靠BUS线连接</li>
<li>浪潮AS1100H的网线口做管理口使用，需要使用对应版本的SANtricity软件进行配置。这个比较蛋疼，因为管理的时候你只有Windows客户端，<br>没有其它办法……不如浪潮的服务器好用，毕竟好歹浪潮的服务器还支持MGMT口浏览器查看和JAVA管理客户端。AS1100H存储……只支持Windows的SANtricity客户端。</li>
<li>AS1100H必须使用最新的，也就是2.20这个版本或（未来可能有）更新的SANTricity才能管理磁盘阵列，早一个版本都不行……</li>
<li>AS1100H的机头分A（左）和B（右）两部分连接管理时需要在A和B的相同网线口的Port编号接出两根网线（请用6类或超5类或更好的线），另一端接入一个交换机，<br>然后再从交换机与计算机连接，运行SANTricity才能找到这个阵列信息。</li>
<li>AS1100H特别蛋疼的还有一个问题，校时的延迟问题，差不多平均一年系统时钟慢8分钟左右……所以个人建议最好是每半年通过SANTricity连接并校时一次。</li>
<li>AS1100H的机头IP地址是有默认值的，分别是A部192.168.128.1、和B部192.168.128.2</li>
<li>AS1100H的授权主要分为分组授权和独立授权。独立授权时主机分别独占一个分区授权，一个分区只能分配给一个主机使用，适合像我这次遇到的客户之前请的“专家”设<br>置了这个授权且客户只想冷备一台主机的情况……如果是双机热备做队列写入的话，推荐使用分组授权，所有组内的主机使用同一个分区授权，每次数据传入均通过队列来处理，<br>基本不会出现数据混乱的问题。</li>
</ol>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><p><img src="https://www.z4a.net/images/2018/11/25/1126581688-5beb610949470_articlex.png" alt="设备线路概要图"><br>根据以上我记录的小“知识点”我按照上图做好了光纤连接。</p>
<p>之后进入SANTricity，双击SANTricity中找到的磁盘信息，打开后应该会询问你是否要做校时，看你的心情选择。<br>之后创建主机，如果你的光纤连接正确（即有光对无光），那么SANTricity在创建主机时会直接认出两张HBA卡的wwn号，你就不用额外输入注册了。<br>按照下面这个拓扑逻辑直接配置新主机即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Storage</span><br><span class="line">  |-&gt; Groups(1)</span><br><span class="line">         |-&gt; Host(theSystem)</span><br><span class="line">              |-&gt; type: Linux(DM-MP)</span><br><span class="line">              |-&gt; Interface type: Fibre Channel</span><br><span class="line">                     |-&gt; Host port identifier: 旧服务器HBA卡1WWN</span><br><span class="line">                     |-&gt; Alias: port1</span><br><span class="line">                     |-&gt; Host port identifier: 旧服务器HBA卡2WWN</span><br><span class="line">                     |-&gt; Alias: port2</span><br><span class="line">              |-&gt; Host(theSystemB)</span><br><span class="line">              |-&gt; type: Linux(DM-MP)</span><br><span class="line">              |-&gt; Interface type: Fibre Channel</span><br><span class="line">                     |-&gt; Host port identifier: 新服务器HBA卡1WWN</span><br><span class="line">                     |-&gt; Alias: port1</span><br><span class="line">                     |-&gt; Host port identifier: 新服务器HBA卡2WWN</span><br><span class="line">                     |-&gt; Alias: port2</span><br></pre></td></tr></table></figure>
<p>接下来的操作就要注意了：如果主机是独立授权的，那么<strong>在下面操作前，一定要先停掉旧系统的相关服务，卸载卷，以免出现两台主机同时写一个扇区的严重问题</strong>！</p>
<p>做到这里后，点击选择theSystem（也就是之前创建的旧服务器），就会看到之前专家给绑定的那个22T的卷，选择“change…”做变更，记住LUN号，<br>选择主机改为”theSystemB”，LUN号选择相同的号码。点确定。SANTricity会弹出警告，要求你<strong>执行前一定要卸载任何已挂载的驱动器，以免数据受损</strong>。</p>
<p>如果卷绑定给了Groups(1)，则没有以上这些担心。但是，客服提醒过我，千万不要将原先是主机独立授权的卷指给分组，否则数据旧读不了了。</p>
<p>这样基本硬件层面基本上就配置完毕了。打开新服务器，进入CentOS7……这里要再唠叨一句……浪潮的NF5270M3是真特么慢啊……而且不支持绝对UEFI，各位为政府客户<br>提出采购建议前一定要注意。CMS真的关不了，UEFI版本为1.x，环境为伪UEFI，设置为UEFI first时服务器启动将会提高3倍的速度，因为所有自检程序只能在MBR<br>下运行，所以一到了UEFI就全跳了……Orz</p>
<p>我还要再啰嗦一句……浪潮的NF5270M3真的很牛X……关闭所有网卡的PXE可以再提高一倍的启动速度！……Orz……不过这台服务器真的比所有SystemX的塔式服务器都快很多倍。</p>
<p>启动CentOS7后，做了该做的事情后（看你了，比如预先安装JAVA环境、yum yupdate、安装一些其它软件等）先安装Linux自带多路径服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install device-mapper-multipath -y</span><br></pre></td></tr></table></figure>
<p>之后获取连接的设备的wwid。这个wwid有两种方法获得，一个是通过SANTricity，点击卷属性-&gt;详细可以看到一组WWID信息，看起来像是16位MAC地址。<br>去掉当中的”:”，将全部数值记录下来。</p>
<p>如果你使用的ssh连接服务器，你也可以用如下命令直接复制查询结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;lib&#x2F;udev&#x2F;scsi_id -g -u &#x2F;dev&#x2F;sd&lt;n&gt;</span><br><span class="line">#这个&lt;n&gt;就是你的硬件标识符，一般是你的hd或sd后面序号+1</span><br></pre></td></tr></table></figure>
<p>然后设置启用（即开机自启动）多路径服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable multipathd</span><br><span class="line">#这里说明以下，启用服务和开始服务一般只要没有名字冲突，不需要特地加.service或.socket指名区分。</span><br></pre></td></tr></table></figure>
<p>然后导入默认的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;doc&#x2F;device-mapper-multipath-0.4.9&#x2F;multipath.conf &#x2F;etc&#x2F;multipath.conf</span><br></pre></td></tr></table></figure>
<p>我用了两三天把整个multipath.conf文件的官方说明好好看了一下，并将其整理做了翻译，如果你有其他方面的想法，可以参考我这个文件：<br><a target="_blank" rel="noopener" href="https://github.com/Bedivere-Sun/man/blob/master/man5/multipath.conf">mutipath.conf(5)</a>…</p>
<p>因为我的服务器非常简单，三块本地磁盘做了个RAID5，所以就只有个sda。基本上为了区别本地磁盘和存储阵列，在多路径配置的第一步就是在黑名单里把本地磁盘给列出来。<br>我这里直接用了个最简单的正则匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">    devnode &quot;^sda&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在multipath部分把wwid加上，记住这里一定要把你得到的wwid的冒号去掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multipath [</span><br><span class="line">    wwid 00112233445566778899aabbccddeeff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在device部分把你的存储详细信息写一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devices &#123;</span><br><span class="line">        device &#123;</span><br><span class="line">                vendor                  &quot;Inspur&quot;</span><br><span class="line">                product                 &quot;AS1100H&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都写好之后，保存文件，设置多路径服务为启用的状态（启用即开机启动）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable multipathd.service</span><br></pre></td></tr></table></figure>
<p>之后重启服务器，让它在开机的时候做一次扫描。扫描后你可以通过<code>multipath -ll</code>查看多路径服务的状态，也可以通过<code>lsblk</code>命令查看多路径对应的服务器。</p>
<p>通常多路径服务默认会给第一个卷命名为“yellow”，这个映射可以在/dev/mapper/中找到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &#x2F;dev&#x2F;mapper&#x2F;yellow</span><br></pre></td></tr></table></figure>
<p>通过上面这个指令可以得知映射出来的是个什么文件，一般都是块文件，直接mount就可以了。</p>
<p>最后还是要多一句嘴：<br>如果是主机独立授权，一定要保证存储的卷一次只被一个主机挂载。我虽然没尝试过吧，但是抱着宁可信其有的态度，还是要多加小心。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/11/21/866c9df7c3fc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/21/866c9df7c3fc/" class="post-title-link" itemprop="url">为NAT网络设置端口转发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-21 14:08:37" itemprop="dateCreated datePublished" datetime="2018-11-21T14:08:37+08:00">2018-11-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:09:26" itemprop="dateModified" datetime="2020-12-25T14:09:26+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">文档翻译</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>写这个是因为当时不太明白这个端口转发怎么用。所以有此译文。大体意思是对的，翻译质量一般。以下是正文：</p>
<p>当虚拟机使用NAT或其它VirtualBox内部网络连接时，其状态在主机同一层面来说是不可见的。也就是说，虚拟机实例所提供的服务是不能通过主机或其它终端直接连接处理的。然而，VirtualBox可以通过端口转发将指定的服务提供给外界。这一过程相当于VirtualBox在主机上监听指定的端口然后将其大包以相同的方式转发给各个不同的虚拟机端口。</p>
<p>对于应用此技术的主机或其它（物理或虚拟的）机器而言，这就好比将服务代理给了一个真实运行的主机上。这也就意味着你不能将相同的服务运行在相同的主机端口上。然而，你依旧可以从中获益——比如你可以在非主机操作系统下启动服务，而你的主机或其它（物理或虚拟）机器也不会因某个bug或致命的（尤其是安全）问题而停止服务。</p>
<p>你可以用图形化界面的“端口转发规则”配置NAT网络适配器的端口转发设置。在这个界面里你可以允许通过特殊端口来映射主机与虚拟机间的网络流量控制。此外你也可以通过命令行工具 VBoxManage modifyvm完成设置。具体可以参考8.8 “VBoxManage modifyvm”。</p>
<p>你首先应该知道将虚拟机的哪个对应服务端口指向主机（通常你可能会将主机和虚拟机的端口号设置为同一个）。你可以将主机上任何未使用的端口号映射给虚拟机。比如你可以通过以下命令配置建立一个NAT到虚拟机的ssh服务的转发规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage modifyvm &quot;目标虚拟机名&quot; --natpf1 &quot;规则名, tcp, , 2222, , 22</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，所有来自主机2222端口的流量请求都会被转发给虚拟机的22端口。要注意的是tcp属性是必须指定的，它决定了转发什么协议的流量（你也可以设置为udp或者其它的什么）。规则名就是这个转发规则的一个标志名称，如果未指定规则名，则执行命令后会自动生成一个。在–natpf后面的数字1是虚拟机网卡的编号。其它VBoxManage中涉及到的–natpf参数也是这个意思。</p>
<p>如果要删除这条规则，你可使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage modifyvm &quot;目标虚拟机名&quot; --natpf1 delete &quot;规则名&quot;</span><br></pre></td></tr></table></figure>
<p>如果你的目标虚拟机实例没有采用内置的HDCP服务那么就要给在设置规则时指定目标虚拟机的ip地址： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage modifyvm &quot;目标虚拟机名&quot; --natpf1 &quot;规则名,tcp,,2222,10.0.2.19,22&quot;</span><br></pre></td></tr></table></figure>
<p>上面这条命令和之前那条ssh端口转发规则几乎相同，它只是告诉NAT网络这个虚拟机对象在10.0.2.19。如果要指定所有流量经目标主机转发，则可以使用如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage modifyvm &quot;目标虚拟机名&quot; --natpf1 &quot;规则名,tcp,127.0.0.1,2222,,22&quot;</span><br></pre></td></tr></table></figure>
<p>这样做会将所有通过TCP访问localhost（127.0.0.1）22端口的流量都转发给虚拟机实例的22端口。</p>
<p>同样的，你也可以实现在虚拟机运行时对NAT连接的访问设置。具体请参考 8.13 “VBoxManage controlvm”。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/11/20/db026d455ecb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/20/db026d455ecb/" class="post-title-link" itemprop="url">GNU C编译器更高版本的安装总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-20 14:04:55" itemprop="dateCreated datePublished" datetime="2018-11-20T14:04:55+08:00">2018-11-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:05:42" itemprop="dateModified" datetime="2020-12-25T14:05:42+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如题，今天在搞一个小服务器，系统是CentOS6的。要求是让部署一个软件，这个软件需要GCC7来编译安装……抛开开发的脑子有包居然要在centos6上编译一个用gcc7才能搞的这种让人匪夷所思的问题不讲。我是百度了一下更新编译安装的流程，这里就记录一下自己的这个经过。</p>
<h3 id="前提要求"><a href="#前提要求" class="headerlink" title="前提要求"></a>前提要求</h3><h4 id="最基本要求"><a href="#最基本要求" class="headerlink" title="最基本要求"></a>最基本要求</h4><p>如果要编译更新的是gcc编译器，那你就要有gcc。因为每个新的编译器都是用旧编译器给编译出来的……别问我那么先有鸡还是先有的蛋……gcc怎么来的……我可以和你胡扯说第一版是汇编出来的——因为我也不懂……总之如果要更新gcc编译器，就要事先保证系统里有比较旧版本的gcc编译器。同样的，如果你要用ada，那你就要先有一个旧版的ada。如果要g++那就要有旧版的g++。</p>
<h4 id="预编译-安装的环境"><a href="#预编译-安装的环境" class="headerlink" title="预编译/安装的环境"></a>预编译/安装的环境</h4><p>编译gcc前要有对应版本的环境做支持。直接<code>./configure</code>、 <code>make</code>、 <code>make install</code>就可以了。如果你不想这么麻烦，你可以下载到对应的bz2包到解压的gcc文件夹里，make的时候检查环境没有的话会自动帮你编译安装。<br>    这里一定要注意： mpc是.gz包，用bz2的包make的时候识别不到。</p>
<h5 id="GNU-C编译器所有版本软件预编译-安装环境包的下载地址："><a href="#GNU-C编译器所有版本软件预编译-安装环境包的下载地址：" class="headerlink" title="GNU C编译器所有版本软件预编译/安装环境包的下载地址："></a>GNU C编译器所有版本软件预编译/安装环境包的下载地址：</h5><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/pub/gcc/infrastructure/">https://gcc.gnu.org/pub/gcc/infrastructure/</a></p>
<p>基本上编译gcc主要需要四个环境：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://gmplib.org/">gmp</a>  : 任意精度的有理数计算库</li>
<li><a target="_blank" rel="noopener" href="https://www.mpfr.org/">mpfr</a> : 高精度浮点计算库</li>
<li><a target="_blank" rel="noopener" href="http://www.multiprecision.org/mpc/">mpc</a>  : 任意复杂度的复数计算库</li>
<li><a target="_blank" rel="noopener" href="http://isl.gforge.inria.fr/">isl</a>  : 线性代数库</li>
</ol>
<h5 id="gcc-8-2-0所需要的环境包下载地址："><a href="#gcc-8-2-0所需要的环境包下载地址：" class="headerlink" title="gcc 8.2.0所需要的环境包下载地址："></a>gcc 8.2.0所需要的环境包下载地址：</h5><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2">gmp-6.1.0.tar.bz2</a><br><a target="_blank" rel="noopener" href="https://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2">mpfr-3.1.4.tar.bz2</a><br><a target="_blank" rel="noopener" href="https://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz">mpc-1.0.3.tar.gz</a><br><a target="_blank" rel="noopener" href="https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2">isl-0.18.tar.bz2</a></p>
<h5 id="我自己提供的加速器："><a href="#我自己提供的加速器：" class="headerlink" title="我自己提供的加速器："></a>我自己提供的加速器：</h5><p>还没做，我只是计划增加一个下OSS载节点……Orz</p>
<h5 id="最省事的办法"><a href="#最省事的办法" class="headerlink" title="最省事的办法"></a>最省事的办法</h5><p>我才知道的在gcc中有一个名为<code>contrib/download_prerequisites</code>的bash脚本，直接运行就可以下载到对应版本的环境包。</p>
<h3 id="超简单几步更新安装gcc"><a href="#超简单几步更新安装gcc" class="headerlink" title="超简单几步更新安装gcc"></a>超简单几步更新安装gcc</h3><ol>
<li>在GNU找到对应版本的gcc<br><a target="_blank" rel="noopener" href="http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/">http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/</a></li>
</ol>
<ol start="2">
<li><p>在解压好的gcc文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir gcc_build</span><br><span class="line">cd gcc_build</span><br></pre></td></tr></table></figure>
<p>这里的gcc_build就是自己建立的一个文件夹名称，用来放编译时必要的文件的。因为如果你编译失败了，或者少点什么没能一次通过，一旦用<code>make clean</code>清除的时候会把文件夹下所有文件都删除。</p>
</li>
<li><p>configure<br>现在你应该在gcc_build或者你自己起好名字的文件夹里了</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">..&#x2F;configure --enable-checking&#x3D;release \</span><br><span class="line">             --enable-languages&#x3D;c \</span><br><span class="line">             --disable-multilib \</span><br><span class="line">             --prefix&#x3D;&#x2F;gcc&#x2F;8.2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明一下：<br><code>--enable-checking=release</code> ：编译前先检查，避免一些不必要的错误。取消检查可设置为<code>--disable-checking</code><br><code>--enable-languages=c</code>      ：字如其意，要用什么编译器就写什么，比如ada就把c改为ada，如果是c++那就改成c++<br><code>--disable-multilib</code>        ：因为我是64位的系统，所以设置这个以免32位的库过来捣乱（其实我也尝试不用这个选项，好像也没啥影响）<br><code>--prefix=</code>                 ：给指定一个安装目录，给make install用的。默认路径是/usr/local，所以默认安装后gcc相关应用将装到/usr/local/bin，库装到/usr/local/lib</p>
<ol start="4">
<li>make &amp;&amp; make install</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>如果你有多核CPU或者你还没设置CFLAG，可以加一个make -j2。4是核心数，可以更快的占满你的CPU使用（喂）</p>
<ol start="5">
<li>删除旧版本的GNU C编译器</li>
</ol>
<p>使用yum/dnf/yast/apt等包管理器或者用rpm/dpkg安装的旧版gcc就没用了，可以删除。如果你想保留也可以不删除，但是最好把/usr/bin/gcc改个名字，比如gcc-old或者gcc-4.4.7</p>
<ol start="6">
<li>创建软链</li>
</ol>
<p>我默认将gcc安装到了/gcc/8.2.0，你的环境变量还没有配置新gcc的位置。所以如果你没有删除旧版gcc你就会使用原来旧版本的编译器，如果你删除了旧版gcc可能就会被系统提示没有gcc程序。所以要把软链做到/usr/bin中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;gcc&#x2F;8.2.0&#x2F;bin&#x2F;gcc &#x2F;usr&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>如果你希望也使用全新的库，也可以把旧库替代了</p>
<h3 id="一点都不F的AQ"><a href="#一点都不F的AQ" class="headerlink" title="一点都不F的AQ"></a>一点都不F的AQ</h3><ol>
<li><p>如果系统里面原本没有对应的编译器怎么办？<br>用包管理器安装一个编译器。如果你能直接通过包管理器安装8.2.0或者7.x的编译器，那你就不用像我这样编译一个出来。讲真真的没必要这样浪费时间。</p>
</li>
<li><p>既然能直接通过包管理器安装较新版本的编译器，为什么还要这样编译？<br>因为centos6它没有啊（掩面）它只有最高到4.4.7的版本。</p>
</li>
<li><p>为什么不换个ubuntu？<br>因为客户不愿意啊Orz……</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/11/15/fcbf74dfcb37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/15/fcbf74dfcb37/" class="post-title-link" itemprop="url">存储的主机类型总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-15 14:13:58" itemprop="dateCreated datePublished" datetime="2018-11-15T14:13:58+08:00">2018-11-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:14:47" itemprop="dateModified" datetime="2020-12-25T14:14:47+08:00">2020-12-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BB%8F%E9%AA%8C/" itemprop="url" rel="index"><span itemprop="name">经验</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这几天倒腾存储大概明白了主机类型都是怎样的，在这里记录一下。</p>
<p>默认多路经服务的主机类型：<br>这些默认的多路经服务可以直接在对应的管理系统下直接被扫描到，无需额外安装多路经软件/服务</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">管理系统</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AIX MPIO</td>
<td align="center">AIX</td>
</tr>
<tr>
<td align="center">Linux(DM_MP)</td>
<td align="center">Linux</td>
</tr>
<tr>
<td align="center">SVC</td>
<td align="center">IBM</td>
</tr>
<tr>
<td align="center">VMWare</td>
<td align="center">VMWare</td>
</tr>
<tr>
<td align="center">Windows</td>
<td align="center">Windows单机</td>
</tr>
<tr>
<td align="center">Windows ATTO</td>
<td align="center">如果连接的是ATTO的HBA卡时选择</td>
</tr>
<tr>
<td align="center">Windows Clustered</td>
<td align="center">Windows双机或集群</td>
</tr>
</tbody></table>
<p>这里很特殊的是<code>Solaris</code>类型，它分Enable和Disable两个选项。Enable表示Solaris11或之后的版本使用，而Disable则表示Solaris10或之前的版本使用的。</p>
<p>非默认多路经服务的主机类型</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">指定系统</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVT_4M</td>
<td align="center">无</td>
<td align="center">如果硬件是SJI NETAPP合作伙伴的，直接选择这个</td>
</tr>
<tr>
<td align="center">HP-UX</td>
<td align="center">HP-UX</td>
<td align="center">一般情况下标准安装后需要在软件安装盘中安装多路经服务才能扫描到目标块文件</td>
</tr>
<tr>
<td align="center">Mac OS</td>
<td align="center">MacOS X或更新版本</td>
<td align="center">没啥可说的……</td>
</tr>
<tr>
<td align="center">Linux(ATTO)</td>
<td align="center">Linux</td>
<td align="center">如果连接的是ATTO的HBA卡时选择</td>
</tr>
<tr>
<td align="center">Linux(MPP/RDAC)</td>
<td align="center">Redhat/CentOS/Fedora</td>
<td align="center">主要是红帽标准的RDAC多路经服务使用，其它Linux发布版本似乎不那么好使</td>
</tr>
<tr>
<td align="center">Linux(Pathmanager)</td>
<td align="center">Linux</td>
<td align="center">Linux下的其它多路经服务</td>
</tr>
<tr>
<td align="center">FactoryDefault</td>
<td align="center">无</td>
<td align="center">这个是工厂用于测试的模式，一般生产环境根本用不到</td>
</tr>
</tbody></table>
<p>还有一个<code>ONTAP</code>我目前还不知道是干啥用的……</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://koorimeo.gitee.io/2018/11/14/57ed63a3b0f3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Koori">
      <meta itemprop="description" content="一个属于克里喵子的静静的小角落">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="克里喵子">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/14/57ed63a3b0f3/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-14 00:00:00" itemprop="dateCreated datePublished" datetime="2018-11-14T00:00:00+08:00">2018-11-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-25 14:49:38" itemprop="dateModified" datetime="2020-12-25T14:49:38+08:00">2020-12-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这是Hexo设置好之后自动生成的一篇文章。因为我懒，就保留原内容了吧……<br>本博客使用的主题是NexT，github项目地址为：<br><a target="_blank" rel="noopener" href="https://github.com/next-theme/hexo-theme-next">hexo-theme-next-master</a><br>该主题官网为：<br><a target="_blank" rel="noopener" href="https://theme-next.org/">NexT主题官网</a></p>
<p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br>欢迎来到<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! 这是第一篇文章。查看<a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a>获取帮助。如果遇到问题可以到<a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a>或者在<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>给Hexo作者发issue。</p>
<h2 id="Quick-Start-快速上手手册"><a href="#Quick-Start-快速上手手册" class="headerlink" title="Quick Start - 快速上手手册"></a>Quick Start - 快速上手手册</h2><h3 id="Create-a-new-post-新建文章"><a href="#Create-a-new-post-新建文章" class="headerlink" title="Create a new post - 新建文章"></a>Create a new post - 新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/writing">Writing</a></p>
<h3 id="Run-server-运行测试环境"><a href="#Run-server-运行测试环境" class="headerlink" title="Run server - 运行测试环境"></a>Run server - 运行测试环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/server.html">Server</a></p>
<h3 id="Generate-static-files-生成静态文件"><a href="#Generate-static-files-生成静态文件" class="headerlink" title="Generate static files - 生成静态文件"></a>Generate static files - 生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites-发布到远程站点"><a href="#Deploy-to-remote-sites-发布到远程站点" class="headerlink" title="Deploy to remote sites - 发布到远程站点"></a>Deploy to remote sites - 发布到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>






<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Koori</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
